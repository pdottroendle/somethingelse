<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <title>ABCDOS Grid â€” Final SEED Wiring</title>
  <style>
    :root { --green:#32CD32; --port:#333; --grid:#aaa; }
    body { font-family: system-ui, sans-serif; margin: 20px; }
    pre { background:#f6f8fa; padding:12px; border-radius:8px; }
    canvas { border:1px dashed var(--grid); }
    .toolbar { margin:10px 0; display:flex; gap:12px; align-items:center; }
    .toolbar input[type=range]{ width:240px; }
  </style>
</head>
<body>
  <pre>
Final integrated version:
- Ports per spec (A top, B left, O TL corner, C right, D bottom, S BR corner).
- Backward uses AX,BX,OX,CX,DX,SX.
- Zoom enabled.
- NULL simplified: alias N (edge boxes N=1, interior N=0).
- Wires drawn only for outputs with SEED eval==1.
  </pre>
  <div class='toolbar'>
    <label>Zoom: <input id='zoomSlider' type='range' min='50' max='400' value='100'></label>
    <span id='zoomLabel'>100%</span>
  </div>
  <canvas id='gridCanvas' width='900' height='600'></canvas>
<script>
const CFG={EDGE_PREFIX:'\\',LANES:4,PORT_RADIUS:2.5,PORT_COLOR:'#333',WIRE_COLOR:'#32CD32',WIRE_WIDTH:2,WIRE_CAP:'round',CORNER_OFFSET:6,SIDE_MARGIN:6};
const grid={cols:3,rows:2,boxW:160,boxH:120,gapX:30,gapY:30};
function isEdgeBox(x,y){return x===0||y===0||x===grid.cols-1||y===grid.rows-1;}
function rectForBox(bx,by){return{x:20+bx*(grid.boxW+grid.gapX),y:20+by*(grid.boxH+grid.gapY),w:grid.boxW,h:grid.boxH};}
function horizontalSideAnchors(r,lanes,top){const m=CFG.SIDE_MARGIN;const usable=r.w-2*m;const step=usable/(lanes+1);const y=top?r.y:r.y+r.h;const arr=[];for(let i=1;i<=lanes;i++){const x=r.x+m+i*step;arr.push({x:x,y:top?y+2:y-2});}return arr;}
function verticalSideAnchors(r,lanes,left){const m=CFG.SIDE_MARGIN;const usable=r.h-2*m;const step=usable/(lanes+1);const x=left?r.x:r.x+r.w;const arr=[];for(let i=1;i<=lanes;i++){const y=r.y+m+i*step;arr.push({x:left?x+2:x-2,y:y});}return arr;}
function cornerClusterAnchors(r,corner){const o=CFG.CORNER_OFFSET;const pts=[];const dx=[0,o];const dy=[0,o];for(let iy=0;iy<2;iy++){for(let ix=0;ix<2;ix++){let x=r.x,y=r.y;if(corner==='TL'){x+=dx[ix]+2;y+=dy[iy]+2;}if(corner==='TR'){x+=r.w-dx[ix]-2;y+=dy[iy]+2;}if(corner==='BL'){x+=dx[ix]+2;y+=r.h-dy[iy]-2;}if(corner==='BR'){x+=r.w-dx[ix]-2;y+=r.h-dy[iy]-2;}pts.push({x:x,y:y});}}return pts;}
const PortAnchors={forward(r){return{A:horizontalSideAnchors(r,CFG.LANES,true),B:verticalSideAnchors(r,CFG.LANES,true),O:cornerClusterAnchors(r,'TL'),C:verticalSideAnchors(r,CFG.LANES,false),D:horizontalSideAnchors(r,CFG.LANES,false),S:cornerClusterAnchors(r,'BR')};},backward(r){return{AX:horizontalSideAnchors(r,CFG.LANES,true),BX:verticalSideAnchors(r,CFG.LANES,true),OX:cornerClusterAnchors(r,'TL'),CX:verticalSideAnchors(r,CFG.LANES,false),DX:horizontalSideAnchors(r,CFG.LANES,false),SX:cornerClusterAnchors(r,'BR')};}};
function drawPorts(ctx,r,o){const map=(o==='forward')?PortAnchors.forward(r):PortAnchors.backward(r);ctx.save();ctx.strokeStyle=CFG.PORT_COLOR;ctx.lineWidth=1;for(const k in map){for(const p of map[k]){ctx.beginPath();ctx.arc(p.x,p.y,CFG.PORT_RADIUS,0,Math.PI*2);ctx.stroke();}}ctx.restore();}
function neighborXY(o,a,i,x,y){const A=a.toUpperCase();if(o==='forward'){if(A==='A')return{nx:x,ny:y-1,counterpart:'D'};if(A==='B')return{nx:x-1,ny:y,counterpart:'C'};if(A==='O')return{nx:x-1,ny:y-1,counterpart:'S'};}else{if(A==='AX')return{nx:x,ny:y+1,counterpart:'DX'};if(A==='BX')return{nx:x+1,ny:y,counterpart:'CX'};if(A==='OX')return{nx:x+1,ny:y+1,counterpart:'SX'};}return null;}
function parseSeedSpec(s){if(!s||typeof s!=='string')return null;let raw=s.trim();let edge=false;if(raw.startsWith(CFG.EDGE_PREFIX)){edge=true;raw=raw.slice(CFG.EDGE_PREFIX.length);}const m=raw.match(/^([A-Za-z]+)\[(\d+)\]/);if(!m)return null;return{alias:m[1].toUpperCase(),idx:parseInt(m[2],10),edgeGuarded:edge};}
function shouldDrawWire(spec,isEdge,val){if(val!==1)return false;if(spec.edgeGuarded)return isEdge;return true;}
function drawWire(ctx,p1,p2){ctx.save();ctx.strokeStyle=CFG.WIRE_COLOR;ctx.lineWidth=CFG.WIRE_WIDTH;ctx.lineCap=CFG.WIRE_CAP;ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);ctx.stroke();ctx.restore();}
function getPortAnchor(r,o,a,i){const map=(o==='forward')?PortAnchors.forward(r):PortAnchors.backward(r);const arr=map[a];if(!arr)return null;return arr[i%arr.length];}
function renderBox(ctx,bx,by,o,seeds,getVal){const r=rectForBox(bx,by);ctx.save();ctx.setLineDash([6,4]);ctx.strokeStyle='#7a7a7a';ctx.strokeRect(r.x,r.y,r.w,r.h);ctx.restore();drawPorts(ctx,r,o);const edge=isEdgeBox(bx,by);for(const s of seeds){const spec=parseSeedSpec(s);if(!spec)continue;const outs=(o==='forward')?['A','B','O']:['AX','BX','OX'];if(!outs.includes(spec.alias))continue;const val=getVal(spec.alias,spec.idx,bx,by,o,edge);if(!shouldDrawWire(spec,edge,val))continue;const nbr=neighborXY(o,spec.alias,spec.idx,bx,by);if(!nbr)continue;if(nbr.nx<0||nbr.ny<0||nbr.nx>=grid.cols||nbr.ny>=grid.rows)continue;const p1=getPortAnchor(r,o,spec.alias,spec.idx);const p2=getPortAnchor(rectForBox(nbr.nx,nbr.ny),o,nbr.counterpart,spec.idx);if(p1&&p2)drawWire(ctx,p1,p2);}}
function getEvalValue(alias,idx,bx,by,o,edge){if(alias==='N')return edge?1:0;return(idx===0&&by===0)?1:0;}
function redraw(){const c=document.getElementById('gridCanvas');const ctx=c.getContext('2d');ctx.save();Zoom.apply(ctx);ctx.clearRect(0,0,c.width,c.height);for(let by=0;by<grid.rows;by++){for(let bx=0;bx<grid.cols;bx++){const o=(by===0)?'forward':'backward';const seeds=(o==='forward')?['A[0]','B[0]','O[0]','N[0]']:['AX[0]','BX[0]','OX[0]','N[0]'];renderBox(ctx,bx,by,o,seeds,getEvalValue);}}ctx.restore();}
const Zoom=(function(){let s=1.0,px=0,py=0;function attach(cv){const sl=document.getElementById('zoomSlider');const lb=document.getElementById('zoomLabel');cv.addEventListener('wheel',e=>{e.preventDefault();const f=e.deltaY>0?0.9:1.1;s=Math.max(0.5,Math.min(4.0,s*f));if(sl)sl.value=String(Math.round(s*100));if(lb)lb.textContent=sl.value+'%';redraw();},{passive:false});if(sl)sl.addEventListener('input',()=>{s=Math.max(0.5,Math.min(4.0,parseInt(sl.value,10)/100));if(lb)lb.textContent=sl.value+'%';redraw();});}function apply(ctx){ctx.setTransform(s,0,0,s,px,py);}return{attach,apply,getScale:()=>s};})();
const canvas=document.getElementById('gridCanvas');Zoom.attach(canvas);window.addEventListener('load',redraw);
</script>
</body>
</html>