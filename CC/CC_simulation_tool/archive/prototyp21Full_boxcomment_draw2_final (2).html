<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <title>ABCDOS Grid — Final SEED Wiring (Spec‑linked)</title>
  <style>
    :root { --green:#32CD32; --port:#333; --grid:#aaa; }
    body { font-family: system-ui, sans-serif; margin: 20px; }
    pre { background:#f6f8fa; padding:12px; border-radius:8px; }
    canvas { border:1px dashed var(--grid); }
    .toolbar { margin:10px 0; display:flex; gap:12px; align-items:center; }
    .toolbar input[type=range]{ width:240px; }
  </style>
</head>
<body>
  <pre>ABCDOS Grid — Final integrated build with Spec references in code comments.</pre>
  <div class='toolbar'>
    <label>Zoom: <input id='zoomSlider' type='range' min='50' max='400' value='100'></label>
    <span id='zoomLabel'>100%</span>
  </div>
  <canvas id='gridCanvas' width='900' height='600'></canvas>
<script>
// =========================
// [Spec-1] Global Config (fixed lanes, backslash edge-guard, styles)
// =========================
const CFG={EDGE_PREFIX:'\\',LANES:4,PORT_RADIUS:2.5,PORT_COLOR:'#333',WIRE_COLOR:'#32CD32',WIRE_WIDTH:2,WIRE_CAP:'round',CORNER_OFFSET:6,SIDE_MARGIN:6};

// =========================
// [Spec-2] Grid Geometry
// =========================
const grid={cols:3,rows:2,boxW:160,boxH:120,gapX:30,gapY:30};
function isEdgeBox(x,y){return x===0||y===0||x===grid.cols-1||y===grid.rows-1;}
function rectForBox(bx,by){return{x:20+bx*(grid.boxW+grid.gapX),y:20+by*(grid.boxH+grid.gapY),w:grid.boxW,h:grid.boxH};}

// =========================
// [Spec-3] Port Anchors (A,B,O,C,D,S forward; AX,BX,OX,CX,DX,SX backward)
// =========================
function horizontalSideAnchors(r,lanes,top){const m=CFG.SIDE_MARGIN;const usable=r.w-2*m;const step=usable/(lanes+1);const y=top?r.y:r.y+r.h;const arr=[];for(let i=1;i<=lanes;i++){const x=r.x+m+i*step;arr.push({x:x,y:top?y+2:y-2});}return arr;}
function verticalSideAnchors(r,lanes,left){const m=CFG.SIDE_MARGIN;const usable=r.h-2*m;const step=usable/(lanes+1);const x=left?r.x:r.x+r.w;const arr=[];for(let i=1;i<=lanes;i++){const y=r.y+m+i*step;arr.push({x:left?x+2:x-2,y:y});}return arr;}
function cornerClusterAnchors(r,corner){const o=CFG.CORNER_OFFSET;const pts=[];const dx=[0,o];const dy=[0,o];for(let iy=0;iy<2;iy++){for(let ix=0;ix<2;ix++){let x=r.x,y=r.y;if(corner==='TL'){x+=dx[ix]+2;y+=dy[iy]+2;}if(corner==='TR'){x+=r.w-dx[ix]-2;y+=dy[iy]+2;}if(corner==='BL'){x+=dx[ix]+2;y+=r.h-dy[iy]-2;}if(corner==='BR'){x+=r.w-dx[ix]-2;y+=r.h-dy[iy]-2;}pts.push({x:x,y:y});}}return pts;}
const PortAnchors={
  forward(r){return{A:horizontalSideAnchors(r,CFG.LANES,true),B:verticalSideAnchors(r,CFG.LANES,true),O:cornerClusterAnchors(r,'TL'),C:verticalSideAnchors(r,CFG.LANES,false),D:horizontalSideAnchors(r,CFG.LANES,false),S:cornerClusterAnchors(r,'BR')};},
  backward(r){return{AX:horizontalSideAnchors(r,CFG.LANES,true),BX:verticalSideAnchors(r,CFG.LANES,true),OX:cornerClusterAnchors(r,'TL'),CX:verticalSideAnchors(r,CFG.LANES,false),DX:horizontalSideAnchors(r,CFG.LANES,false),SX:cornerClusterAnchors(r,'BR')};}
};

// =========================
// [Spec-4] Port Rendering (always draw small circles)
// =========================
function drawPorts(ctx,r,o){const map=(o==='forward')?PortAnchors.forward(r):PortAnchors.backward(r);ctx.save();ctx.strokeStyle=CFG.PORT_COLOR;ctx.lineWidth=1;for(const k in map){for(const p of map[k]){ctx.beginPath();ctx.arc(p.x,p.y,CFG.PORT_RADIUS,0,Math.PI*2);ctx.stroke();}}ctx.restore();}

// =========================
// [Spec-5] SEED Parsing (alias[idx] + optional expr, backslash edge-guard)
// =========================
function parseSeedSpec(s){if(!s||typeof s!=='string')return null;let raw=s.trim();let edge=false;if(raw.startsWith(CFG.EDGE_PREFIX)){edge=true;raw=raw.slice(CFG.EDGE_PREFIX.length);}const m=raw.match(/^([A-Za-z]+)\[(\d+)\](.*)$/);if(!m)return null;const alias=m[1].toUpperCase();const idx=parseInt(m[2],10);const expr=(m[3]||'').trim();const usesN=/N/.test(expr);return{alias,idx,expr,edgeGuarded:edge,usesN};}

// =========================
// [Spec-6] Box Attribute N (Edge=1, Interior=0)
// =========================
function getNForBox(bx,by){return isEdgeBox(bx,by)?1:0;}

// =========================
// [Spec-7] Neighbor Mapping + Counterparts (Between-box)
// =========================
function neighborXY(o,a,i,x,y){const A=a.toUpperCase();if(o==='forward'){if(A==='A')return{nx:x,ny:y-1,counterpart:'D'};if(A==='B')return{nx:x-1,ny:y,counterpart:'C'};if(A==='O')return{nx:x-1,ny:y-1,counterpart:'S'};}else{if(A==='AX')return{nx:x,ny:y+1,counterpart:'DX'};if(A==='BX')return{nx:x+1,ny:y,counterpart:'CX'};if(A==='OX')return{nx:x+1,ny:y+1,counterpart:'SX'};}return null;}

// =========================
// [Spec-8] Zoom Module (wheel + slider)
// =========================
const Zoom=(function(){let s=1.0,px=0,py=0;function attach(cv){const sl=document.getElementById('zoomSlider');const lb=document.getElementById('zoomLabel');cv.addEventListener('wheel',e=>{e.preventDefault();const f=e.deltaY>0?0.9:1.1;s=Math.max(0.5,Math.min(4.0,s*f));if(sl)sl.value=String(Math.round(s*100));if(lb)lb.textContent=sl.value+'%';redraw();},{passive:false});if(sl)sl.addEventListener('input',()=>{s=Math.max(0.5,Math.min(4.0,parseInt(sl.value,10)/100));if(lb)lb.textContent=sl.value+'%';redraw();});}function apply(ctx){ctx.setTransform(s,0,0,s,px,py);}function getScale(){return s;}return{attach,apply,getScale};})();

// =========================
// [Spec-9] Wire Style (adaptive blur with scale & local density)
// =========================
function styleForLines(scale,lineCount){const width=Math.max(1,CFG.WIRE_WIDTH*Math.max(0.75,Math.min(1.5,scale)));const blur=Math.min(10,Math.max(0,(lineCount>12?8:lineCount>6?5:3)/Math.max(1,scale)));const alpha=0.9;return{width,blur,alpha};}
function drawWire(ctx,p1,p2,scale,lineCount){const s=styleForLines(scale,lineCount||1);ctx.save();ctx.strokeStyle=CFG.WIRE_COLOR;ctx.lineWidth=s.width;ctx.lineCap=CFG.WIRE_CAP;ctx.globalAlpha=s.alpha;ctx.shadowColor=CFG.WIRE_COLOR;ctx.shadowBlur=s.blur;ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);ctx.stroke();ctx.restore();}

// =========================
// [Spec-10] Output-only wire decision (SEED eval==1, N gating, edge-guard)
// =========================
function shouldDrawWire(spec,isEdge,val,N){if(val!==1)return false;if(spec.usesN&&N!==1)return false;if(spec.edgeGuarded&&!isEdge)return false;return true;}

// =========================
// [Spec-11] Port Anchor Lookup
// =========================
function getPortAnchor(r,o,a,i){const map=(o==='forward')?PortAnchors.forward(r):PortAnchors.backward(r);const arr=map[a];if(!arr)return null;return arr[i%arr.length];}

// =========================
// [Spec-12] Box Renderer (frame, ports, wires)
// =========================
function renderBox(ctx,bx,by,o,seeds,getVal){const r=rectForBox(bx,by);ctx.save();ctx.setLineDash([6,4]);ctx.strokeStyle='#7a7a7a';ctx.strokeRect(r.x,r.y,r.w,r.h);ctx.restore();drawPorts(ctx,r,o);const edge=isEdgeBox(bx,by);const N=getNForBox(bx,by);const scale=Zoom.getScale();let localCount=seeds.length;for(const s of seeds){const spec=parseSeedSpec(s);if(!spec)continue;const outs=(o==='forward')?['A','B','O']:['AX','BX','OX'];if(!outs.includes(spec.alias))continue;const val=getVal(spec.alias,spec.idx,bx,by,o,N,edge);if(!shouldDrawWire(spec,edge,val,N))continue;const nbr=neighborXY(o,spec.alias,spec.idx,bx,by);if(!nbr)continue;if(nbr.nx<0||nbr.ny<0||nbr.nx>=grid.cols||nbr.ny>=grid.rows)continue;const p1=getPortAnchor(r,o,spec.alias,spec.idx);const p2=getPortAnchor(rectForBox(nbr.nx,nbr.ny),o,nbr.counterpart,spec.idx);if(p1&&p2)drawWire(ctx,p1,p2,scale,localCount);}}

// =========================
// [Spec-13] Evaluator Hook (demo)
// =========================
function getEvalValue(alias,idx,bx,by,o,N,edge){ // Replace with your real evaluator
  // Demo: lane 0 in top row evaluates to 1; others 0
  return (idx===0 && by===0) ? 1 : 0;
}

// =========================
// [Spec-14] Redraw + Seeds (show '&& N' gating)
// =========================
function redraw(){const c=document.getElementById('gridCanvas');const ctx=c.getContext('2d');ctx.save();Zoom.apply(ctx);ctx.clearRect(0,0,c.width,c.height);for(let by=0;by<grid.rows;by++){for(let bx=0;bx<grid.cols;bx++){const o=(by===0)?'forward':'backward';const seeds=(o==='forward')?['A[0] && N','B[0]','O[0]']:['AX[0] && N','BX[0]','OX[0]'];renderBox(ctx,bx,by,o,seeds,getEvalValue);}}ctx.restore();}

// =========================
// [Spec-15] Bootstrap (Zoom attach and initial draw)
// =========================
const canvas=document.getElementById('gridCanvas');Zoom.attach(canvas);window.addEventListener('load',redraw);
</script>
</body>
</html>
