<!DOCTYPE html>
<html><head>
<meta charset="utf-8"/>
<title>ABCDOS Grid — Final SEED Wiring (Spec‑linked)</title>
<style>
    :root { --green:#32CD32; --port:#333; --grid:#aaa; }
    body { font-family: system-ui, sans-serif; margin: 20px; }
    pre { background:#f6f8fa; padding:12px; border-radius:8px; }
    canvas { border:1px dashed var(--grid); }
    .toolbar { margin:10px 0; display:flex; gap:12px; align-items:center; }
    .toolbar input[type=range]{ width:240px; }
  </style>
<style>
#stage{position:relative;width:1600px;height:1200px;left:220px;top:140px;}
#stage>*{position:absolute;left:0;top:0}
#topRightImage{left:0;top:0;width:450px;height:auto;z-index:1000}
#gridCanvas{left:0;top:0}
#canvas{left:0;top:0}
</style></head><body><pre>ABCDOS Grid — Final integrated build with Spec references in code comments.</pre><div class="toolbar">
<label>Zoom: <input id="zoomSlider" max="400" min="50" type="range" value="100"/></label>
<span id="zoomLabel">100%</span>
</div><canvas height="600" id="gridCanvas" width="900"></canvas><script>
// =========================
// [Spec-1] Global Config (fixed lanes, backslash edge-guard, styles)
// =========================
const CFG={EDGE_PREFIX:'\\',LANES:4,PORT_RADIUS:2.5,PORT_COLOR:'#333',WIRE_COLOR:'#32CD32',WIRE_WIDTH:2,WIRE_CAP:'round',CORNER_OFFSET:6,SIDE_MARGIN:6};

// =========================
// [Spec-2] Grid Geometry
// =========================
const grid={cols:3,rows:2,boxW:160,boxH:120,gapX:30,gapY:30};
function isEdgeBox(x,y){return x===0||y===0||x===grid.cols-1||y===grid.rows-1;}
function rectForBox(bx,by){return{x:20+bx*(grid.boxW+grid.gapX),y:20+by*(grid.boxH+grid.gapY),w:grid.boxW,h:grid.boxH};}

// =========================
// [Spec-3] Port Anchors (A,B,O,C,D,S forward; AX,BX,OX,CX,DX,SX backward)
// =========================
function horizontalSideAnchors(r,lanes,top){const m=CFG.SIDE_MARGIN;const usable=r.w-2*m;const step=usable/(lanes+1);const y=top?r.y:r.y+r.h;const arr=[];for(let i=1;i<=lanes;i++){const x=r.x+m+i*step;arr.push({x:x,y:top?y+2:y-2});}return arr;}
function verticalSideAnchors(r,lanes,left){const m=CFG.SIDE_MARGIN;const usable=r.h-2*m;const step=usable/(lanes+1);const x=left?r.x:r.x+r.w;const arr=[];for(let i=1;i<=lanes;i++){const y=r.y+m+i*step;arr.push({x:left?x+2:x-2,y:y});}return arr;}
function cornerClusterAnchors(r,corner){const o=CFG.CORNER_OFFSET;const pts=[];const dx=[0,o];const dy=[0,o];for(let iy=0;iy<2;iy++){for(let ix=0;ix<2;ix++){let x=r.x,y=r.y;if(corner==='TL'){x+=dx[ix]+2;y+=dy[iy]+2;}if(corner==='TR'){x+=r.w-dx[ix]-2;y+=dy[iy]+2;}if(corner==='BL'){x+=dx[ix]+2;y+=r.h-dy[iy]-2;}if(corner==='BR'){x+=r.w-dx[ix]-2;y+=r.h-dy[iy]-2;}pts.push({x:x,y:y});}}return pts;}
const PortAnchors={
  forward(r){return{A:horizontalSideAnchors(r,CFG.LANES,true),B:verticalSideAnchors(r,CFG.LANES,true),O:cornerClusterAnchors(r,'TL'),C:verticalSideAnchors(r,CFG.LANES,false),D:horizontalSideAnchors(r,CFG.LANES,false),S:cornerClusterAnchors(r,'BR')};},
  backward(r){return{AX:horizontalSideAnchors(r,CFG.LANES,true),BX:verticalSideAnchors(r,CFG.LANES,true),OX:cornerClusterAnchors(r,'TL'),CX:verticalSideAnchors(r,CFG.LANES,false),DX:horizontalSideAnchors(r,CFG.LANES,false),SX:cornerClusterAnchors(r,'BR')};}
};

// =========================
// [Spec-4] Port Rendering (always draw small circles)
// =========================
function drawPorts(ctx,r,o){const map=(o==='forward')?PortAnchors.forward(r):PortAnchors.backward(r);ctx.save();ctx.strokeStyle=CFG.PORT_COLOR;ctx.lineWidth=1;for(const k in map){for(const p of map[k]){ctx.beginPath();ctx.arc(p.x,p.y,CFG.PORT_RADIUS,0,Math.PI*2);ctx.stroke();}}ctx.restore();}

// =========================
// [Spec-5] SEED Parsing (alias[idx] + optional expr, backslash edge-guard)
// =========================
function parseSeedSpec(s){if(!s||typeof s!=='string')return null;let raw=s.trim();let edge=false;if(raw.startsWith(CFG.EDGE_PREFIX)){edge=true;raw=raw.slice(CFG.EDGE_PREFIX.length);}const m=raw.match(/^([A-Za-z]+)\[(\d+)\](.*)$/);if(!m)return null;const alias=m[1].toUpperCase();const idx=parseInt(m[2],10);const expr=(m[3]||'').trim();const usesN=/N/.test(expr);return{alias,idx,expr,edgeGuarded:edge,usesN};}

// =========================
// [Spec-6] Box Attribute N (Edge=1, Interior=0)
// =========================
function getNForBox(bx,by){return isEdgeBox(bx,by)?1:0;}

// =========================
// [Spec-7] Neighbor Mapping + Counterparts (Between-box)
// =========================
function neighborXY(o,a,i,x,y){const A=a.toUpperCase();if(o==='forward'){if(A==='A')return{nx:x,ny:y-1,counterpart:'D'};if(A==='B')return{nx:x-1,ny:y,counterpart:'C'};if(A==='O')return{nx:x-1,ny:y-1,counterpart:'S'};}else{if(A==='AX')return{nx:x,ny:y+1,counterpart:'DX'};if(A==='BX')return{nx:x+1,ny:y,counterpart:'CX'};if(A==='OX')return{nx:x+1,ny:y+1,counterpart:'SX'};}return null;}

// =========================
// [Spec-8] Zoom Module (wheel + slider)
// =========================
const Zoom=(function(){let s=1.0,px=0,py=0;function attach(cv){const sl=document.getElementById('zoomSlider');const lb=document.getElementById('zoomLabel');cv.addEventListener('wheel',e=>{e.preventDefault();const f=e.deltaY>0?0.9:1.1;s=Math.max(0.5,Math.min(4.0,s*f));if(sl)sl.value=String(Math.round(s*100));if(lb)lb.textContent=sl.value+'%';redraw();},{passive:false});if(sl)sl.addEventListener('input',()=>{s=Math.max(0.5,Math.min(4.0,parseInt(sl.value,10)/100));if(lb)lb.textContent=sl.value+'%';redraw();});}function apply(ctx){ctx.setTransform(s,0,0,s,px,py);}function getScale(){return s;}return{attach,apply,getScale};})();

// =========================
// [Spec-9] Wire Style (adaptive blur with scale & local density)
// =========================
function styleForLines(scale,lineCount){const width=Math.max(1,CFG.WIRE_WIDTH*Math.max(0.75,Math.min(1.5,scale)));const blur=Math.min(10,Math.max(0,(lineCount>12?8:lineCount>6?5:3)/Math.max(1,scale)));const alpha=0.9;return{width,blur,alpha};}
function drawWire(ctx,p1,p2,scale,lineCount){const s=styleForLines(scale,lineCount||1);ctx.save();ctx.strokeStyle=CFG.WIRE_COLOR;ctx.lineWidth=s.width;ctx.lineCap=CFG.WIRE_CAP;ctx.globalAlpha=s.alpha;ctx.shadowColor=CFG.WIRE_COLOR;ctx.shadowBlur=s.blur;ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);ctx.stroke();ctx.restore();}

// =========================
// [Spec-10] Output-only wire decision (SEED eval==1, N gating, edge-guard)
// =========================
function shouldDrawWire(spec,isEdge,val,N){if(val!==1)return false;if(spec.usesN&&N!==1)return false;if(spec.edgeGuarded&&!isEdge)return false;return true;}

// =========================
// [Spec-11] Port Anchor Lookup
// =========================
function getPortAnchor(r,o,a,i){const map=(o==='forward')?PortAnchors.forward(r):PortAnchors.backward(r);const arr=map[a];if(!arr)return null;return arr[i%arr.length];}

// =========================
// [Spec-12] Box Renderer (frame, ports, wires)
// =========================
function renderBox(ctx,bx,by,o,seeds,getVal){const r=rectForBox(bx,by);ctx.save();ctx.setLineDash([6,4]);ctx.strokeStyle='#7a7a7a';ctx.strokeRect(r.x,r.y,r.w,r.h);ctx.restore();drawPorts(ctx,r,o);const edge=isEdgeBox(bx,by);const N=getNForBox(bx,by);const scale=Zoom.getScale();let localCount=seeds.length;for(const s of seeds){const spec=parseSeedSpec(s);if(!spec)continue;const outs=(o==='forward')?['A','B','O']:['AX','BX','OX'];if(!outs.includes(spec.alias))continue;const val=getVal(spec.alias,spec.idx,bx,by,o,N,edge);if(!shouldDrawWire(spec,edge,val,N))continue;const nbr=neighborXY(o,spec.alias,spec.idx,bx,by);if(!nbr)continue;if(nbr.nx<0||nbr.ny<0||nbr.nx>=grid.cols||nbr.ny>=grid.rows)continue;const p1=getPortAnchor(r,o,spec.alias,spec.idx);const p2=getPortAnchor(rectForBox(nbr.nx,nbr.ny),o,nbr.counterpart,spec.idx);if(p1&&p2)drawWire(ctx,p1,p2,scale,localCount);}}

// =========================
// [Spec-13] Evaluator Hook (demo)
// =========================
function getEvalValue(alias,idx,bx,by,o,N,edge){ // Replace with your real evaluator
  // Demo: lane 0 in top row evaluates to 1; others 0
  return (idx===0 && by===0) ? 1 : 0;
}

// =========================
// [Spec-14] Redraw + Seeds (show '&& N' gating)
// =========================
function redraw(){const c=document.getElementById('gridCanvas');const ctx=c.getContext('2d');ctx.save();Zoom.apply(ctx);ctx.clearRect(0,0,c.width,c.height);for(let by=0;by<grid.rows;by++){for(let bx=0;bx<grid.cols;bx++){const o=(by===0)?'forward':'backward';const seeds=(o==='forward')?['A[0] && N','B[0]','O[0]']:['AX[0] && N','BX[0]','OX[0]'];renderBox(ctx,bx,by,o,seeds,getEvalValue);}}ctx.restore();}

// =========================
// [Spec-15] Bootstrap (Zoom attach and initial draw)
// =========================
const canvas=document.getElementById('gridCanvas');Zoom.attach(canvas);window.addEventListener('load',redraw);
</script><div id="stage"><img alt="scale map" id="topRightImage" src="Scale.jpg"/><canvas height="600" id="gridCanvas" width="900"></canvas><canvas height="800" id="canvas" width="800"></canvas></div><input id="inputA" placeholder="Enter hex string A" type="text"/><input id="inputB" placeholder="Enter hex string B" type="text"/><textarea cols="35" id="userInput" oninput="updateMasterBool()" rows="17"></textarea><input id="updateInput" placeholder="0.0.1=3" type="text"/><div id="selectionDisplay0" style="margin-top:8px;"></div><div id="selectionDisplay" style="margin-top:8px;"></div><pre id="jsonOutput"></pre><pre aria-labelledby="masterBoolDisplayLabel" id="masterBoolDisplay"></pre><span id="masterBoolDisplayLabel">Display:</span><script> 
// WARNING: Equations with loops are prohibited, as the simulation 
// only does 2 runs top left to bottom right for ABO and then the opposite dxcxsx
// the code needs to leave the booleans unresolved if a return data is expected
// example box0,0 A[0] = B[0] && sx [0]<< this is only available ont he return run
// WARNING: edge boxes need have NULL NEEDS TO BE INTEGRATED - TBD //
 		/* Systolic Arrays - Application for anyone Booleans to be experimented
		// this tool is free for the public - anyones booleans is theirs
		// For science and humanity
		// Peter-Paul Troendle
		// Made in 
		//
                //		USA, WA 2025 
		//      Digital Xlyns Inc. 
		//      All Rights Reserved
		//
		//Files: Prototyp.html README.txt fubctional.js graphical.js
		//==================================================
		// ABCOS 8x8 (or any scale)
		//              O _______ A_______
		//               |E|E|E|E|E|E|E|E|\  
		//               |E|E|E|E|E|E|E|E|\  
		//               |E|E|E|E|E|E|E|E|\  
		//            B  |E|E|E|E|E|E|E|E|\  C
		//               |E|E|E|E|E|E|E|E|\  
		//               |E|E|E|E|E|E|E|E|\  
		//               |E|E|E|E|E|E|E|E|\  
		//               |E|E|E|E|E|E|E|E|\  
		//                ---------------- S
		//                  \ \ \ \ \ \ \ \
		//                    \ \ \ \ \ \ \ 
		//                      \ \ \ \ \ \
		//                        \ \ \ \ \ C extended
		//               (using S)  \ \ \ \ 
		//                            \ \ \
		//                              \ \
		//                                \
		// D output extends C : output[0] = C in full 
		//
		// ABCDOS
		// E 3 directional (atomic element) 
		// 2x3x4 inputs : bi-directional x 4 channels x 3 directions 
		//      O -------A--------
		//      |ox     ax      |      Forwards:      Backwards:
		//      |  \    |       |      -----x-axis      
		//      |               |      |\                     |
		//     B|bx--       --cx|C     | \                 \  |
		//      |               |      |  \                 \ |    
		//      |        |    \ |      |   \ z-axis          \|
		//      |       dx    sx|      y-axis           ------
		//      ----------------
		//             D         S (ox)
		// x is return path
		// a[0] is the memory bit (that scales)
		// b[0] is the code bit (that scales) 
		// each code bits runs in parallel to the other codes
		// each memory bit is in parallel to all the others 
		// all code access to all memory in one single cycle
		
		//===================================================
		// BOOLEANS used to creatre outputs 
		// eval(equationZ.replace(/x/g, x).replace(/y/g, y).replace(/z/g, z)));
		//===================================================
		// BOX DATA and CODE structure
		// 1 I need in Javascript a input field providing an update value for a json object
        // 2 the updated json object should be displayed on the output fiield of the html page
        // 3 this is the json object initially {{{,,,}{,,,}{,,,}}{{,,,}{,,,}{,,,}}}
        // 4 map the json object to their alias values and initialise with 0 all elements:
             {{{A[0]:0,A[1]:0,A[2]:0,A[3]:0}{B[0]:0,B[1]:0,B[2]:0,B[3]:0}{O[0]:0,O[1]:0,O[2]:0,O[3]:0}}{{dx[0]:0,dx[1]:0,dx[2]:0,dx[3]:0}{cx[0]:0,cx[1]:0,cx[2]:0,cx[3]:0}{sx[0]:0,sx[1]:0,sx[2]:0,sx[3]:0}}} 
        // 5 as example 1.1.2 =1 would yield {{,{,1}}} as example so B[1] would have the value 1, please check this as it will show you understood
		//===================================================
        */
//document.addEventListener('DOMContentLoaded', () => {});
    function formatJSON(json) {
        return JSON.stringify(json, null, 2)
            .replace(/\[\s+/g, '[')
            .replace(/\s+\]/g, ']')
            .replace(/\s*,\s*/g, ',')
            .replace(/,\n\s+/g, ',\n')
            .replace(/],/g, '],\n');
    }

let boxes = [];

let A, B, O;
let d = [0, 0, 0, 0];
let c = [0, 0, 0, 0];
let s = [0, 0, 0, 0];

let inputAx = '';
let inputBy = '';
let xscale = 0;
let yscale = 0;

document.getElementById('inputA').addEventListener('input', updateBoxes);
document.getElementById('inputB').addEventListener('input', updateBoxes);
document.getElementById('userInput').addEventListener('input', updateMasterBool);
document.getElementById('updateInput').addEventListener('input', updateBox);

    let masterBoolObject = '{"forward":[{"A":["A[0]",0,0,0]},{"B":["B[0]",0,0,"A[1] # B[1]"]},{"O":["A[0] && B[1]",0,"A[2] && !O[0]",0]}],"backward":[{"dx":[0,0,0,0]},{"cx":[0,0,0,0]},{"sx":[0,0,0,0]}]}'

    function updateMasterBool() {
        const jsonInput = document.getElementById('userInput').value;
            masterBoolObject = jsonInput; 
            console.log('MasterboolObject updated:', masterBoolObject);
            displayMasterBoolObject();
    }
	
    function displayMasterBoolObject() {
        const masterBoolDisplay = document.getElementById('masterBoolDisplay');
        masterBoolDisplay.textContent = formatJSON(JSON.parse(masterBoolObject));
        document.getElementById('userInput').value = masterBoolObject;
		updateBoxes()
    }
	
// Convert the object to a JSON string
const masterBoolObjectString = JSON.stringify(masterBoolObject);
	
    function updateBoxes() {
 
    console.log('Boxes before update:', boxes.length); // Should be 0

     inputAx = document.getElementById('inputA').value;
     inputBy = document.getElementById('inputB').value;

    // Update xscale and yscale based on the current values of inputAx and inputBy
     xscale = inputAx.length;
     yscale = inputBy.length;

       boxes = []; 

		// line 0 element i=0...N from inputA populates, the.. untill j=N line
        // left right (i:0-N) then next line and so forth (j:0-N)
		for (let j = 0; j < yscale; j++) {
            for (let i = 0; i < xscale; i++) {
                boxes.push({
                    forward: [
                        { A: j === 0 ? hexToNibble(inputAx[i]) : [0, 0, 0, 0] },
                        { B: i === 0 ? hexToNibble(inputBy[j]) : [0, 0, 0, 0] },
                        { O: [0, 0, 0, 0] }
                    ],
                    backward: [
                        { dx: [0, 0, 0, 0] },
                        { cx: [0, 0, 0, 0] },
                        { sx: [0, 0, 0, 0] }
                    ]
                });
				
	
        console.log(`Box added at (${i}, ${j}):`, boxes[boxes.length - 1]);

            }
        }
		

    console.log('Boxes after update:', boxes.length); // Should be 4

        drawCanvas(evaluateBoolObject(boxes));
    }

    function hexToNibble(hex) {
        const num = parseInt(hex, 16);
        return [num & 1, (num >> 1) & 1, (num >> 2) & 1, (num >> 3) & 1];
    }

function evaluateExpression(expression, direction) {

    if (typeof expression !== 'string') {
        return expression; // Return the value as is if it's not a string
    }
    if (direction ==0) {
    // Replace placeholders with actual values
    expression = expression.replace(/A\[(\d+)\]/g, (match, index) => A[index]);
    expression = expression.replace(/B\[(\d+)\]/g, (match, index) => B[index]);
    expression = expression.replace(/O\[(\d+)\]/g, (match, index) => O[index]);
    }else{
    expression = expression.replace(/dx\[(\d+)\]/g, (match, index) => d[index]);
    expression = expression.replace(/cx\[(\d+)\]/g, (match, index) => c[index]);
    expression = expression.replace(/sx\[(\d+)\]/g, (match, index) => s[index]);
    }
    // Replace boolean operators with JavaScript equivalents
    expression = expression.replace(/#/g, '^'); // EXOR
    expression = expression.replace(/!/g, '!'); // NOT
    expression = expression.replace(/&&/g, '&&'); // AND
    expression = expression.replace(/\|\|/g, '||'); // OR 
    
   // Evaluate the expression and convert boolean results to integers
    return eval(expression) ? 1 : 0;

}

function evaluateMasterBoolObject(masterBoolObject, direction) { 
 if (direction ==0) {
    // Evaluate backward array
    masterBoolObject.forward.forEach(item => {
        Object.keys(item).forEach(key => {
            item[key] = item[key].map(expr => evaluateExpression(expr, 0)); 
        });
    });
  } else {
    // Evaluate backward array
    masterBoolObject.backward.forEach(item => {
        Object.keys(item).forEach(key => {
            item[key] = item[key].map(expr => evaluateExpression(expr, 1)); 
        });
    });
  }
    return masterBoolObject;
}
  
function evaluateBoolObject(boxes) {
        const userInputString = document.getElementById('userInput').value;
	    let boolObject = JSON.parse(userInputString);
        console.log('boolObject before Evaluation:', formatJSON(boolObject)); 

console.log('x' + xscale + 'y' + yscale + '>>>>>>>>>>>>'+ boxes.length);
    for (let ii = 0; ii < boxes.length; ii++) {
        let box = boxes[ii];

        if (ii < xscale) {
            A = box.forward[0].A; // x axis
       	    console.log( 'box.forward[0].A' +  box.forward[0].A); 

        } else {
            A = boxes[ii - xscale].forward[0].A; 
	        console.log( 'boxes[ii - xscale].forward[0].A' + boxes[(ii - xscale)].forward[0].A );

        }

        if (ii % xscale === 0) {
            B = box.forward[1].B; // y axis
       	    console.log( 'box.forward[1].B' +  box.forward[1].B); 
        } else {
            B = boxes[ii - 1].forward[1].B;
	        console.log( 'boxes[ii - 1].forward[1].B' + boxes[ii - 1].forward[1].B );
        }

        if (ii < xscale || ii % xscale === 0) {
            O = box.forward[2].O; // z axis
       	    console.log( 'box.forward[2].O' +  box.forward[2].O); 
        } else {
            O = boxes[ii - xscale - 1].forward[2].O;
	        console.log( 'boxes[ii - xscale - 1].forward[2].O' + boxes[ii - xscale - 1].forward[2].O );
        }

   	    boolObject = evaluateMasterBoolObject(boolObject, 0); 
		boxes[ii] = boolObject;
	}

    for (let iz = (boxes.length-1); iz >= 0; iz--) {
        let box = boxes[iz];

        if (iz >= xscale * (yscale  - 1)) {
            d = box.backward[0].dx; // x axis
       	    console.log( 'box.backward[0].dx' +  box.backward[0].dx); 

        } else {
            d = boxes[iz + xscale].backward[0].dx; 
	        console.log( 'boxes[iz - xscale].backward[0].dx' + boxes[(iz + xscale)].backward[0].dx );

        }

        if (iz % xscale === xscale - 1) {
            c = box.backward[1].cx; // y axis
       	    console.log( 'box.backward[1].cx' +  box.backward[1].cx); 
        } else {
            c = boxes[iz + 1].backward[1].cx;
	        console.log( 'boxes[iz + 1].backward[1].cx' + boxes[iz + 1].backward[1].cx );
        }

        if ((iz >= xscale * (yscale  - 1))|| (iz % xscale === xscale - 1)) {
            s = box.backward[2].sx; // z axis
       	    console.log( 'box.backward[2].sx' +  box.backward[2].sx); 
        } else {
            s = boxes[iz + xscale + 1].backward[2].sx;
	        console.log( 'boxes[iz + xscale + 1].backward[2].sx' + boxes[iz + xscale + 1].backward[2].sx );
        }

		//const userInputString = document.getElementById('userInput').value;
        //const boolObject = JSON.parse(userInputString);
        console.log('boolObject after Evaluation:', formatJSON(boolObject)); 
   	    boxes[iz] = evaluateMasterBoolObject( boolObject, 1); 
  }

    return boxes;
}


function drawCanvas(boxes) {

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const boxSize = 800 / Math.max(xscale, yscale);
    boxes.forEach((box, index) => {
        const x = (index % xscale) * boxSize;
        const y = Math.floor(index / xscale) * boxSize;

        let a0, b0, o0, a1, b1, o1, d0, c0, s0, d1, c1, s1;
        box.forward.forEach(item => {
            if (item.A) {a0 = item.A[0]; a1 = item.A}
            if (item.B) {b0 = item.B[0]; b1 = item.B}
            if (item.O) {o0 = item.O[0]; o1 = item.O}
        });
        box.backward.forEach(item => {
            if (item.dx) {d0 = item.dx[0]; d1 = item.dx}
            if (item.cx) {c0 = item.cx[0]; c1 = item.cx}
            if (item.sx) {s0 = item.sx[0]; s1 = item.sx}
        });
		
        console.log(`BOX: ${JSON.stringify(box)}, A: ${a0}, B: ${b0}, O: ${o0}, d: ${d0}, c: ${c0}, s: ${s0}`);

        ctx.strokeRect(x, y, boxSize / 3, boxSize / 3);

        // Put a dot in the boxes with A[0] or B[0] set
        if (a0 || b0) {
            ctx.beginPath();
            ctx.arc(x + boxSize / 6, y + boxSize / 6, 2, 0, 2 * Math.PI);
            ctx.fill();
        }

        // Draw lines
        if (a0 && y + boxSize < 800) {
            ctx.beginPath();
            ctx.moveTo(x + boxSize / 6, y + boxSize / 6);
            ctx.lineTo(x + boxSize / 6, y + boxSize / 6 + boxSize);
            ctx.stroke();
        }
        if (b0 && x + boxSize < 800) {
            ctx.beginPath();
            ctx.moveTo(x + boxSize / 6, y + boxSize / 6);
            ctx.lineTo(x + boxSize / 6 + boxSize, y + boxSize / 6);
            ctx.stroke();
        }
        if (o0 && x + boxSize < 800 && y + boxSize < 800) {
            ctx.beginPath();
            ctx.moveTo(x + boxSize / 6, y + boxSize / 6);
            ctx.lineTo(x + boxSize / 6 + boxSize, y + boxSize / 6 + boxSize);
            ctx.stroke();
        }

        // Draw dx, cx, and sx lines
        if (d0 && y - boxSize >= 0) {
            ctx.beginPath();
            ctx.moveTo(x + boxSize / 6, y + boxSize / 6);
            ctx.lineTo(x + boxSize / 6, y - boxSize / 6);
            ctx.stroke();
        }
        if (c0 && x - boxSize >= 0) {
            ctx.beginPath();
            ctx.moveTo(x + boxSize / 6, y + boxSize / 6);
            ctx.lineTo(x - boxSize / 6, y + boxSize / 6);
            ctx.stroke();
        }
        if (s0 && x - boxSize >= 0 && y - boxSize >= 0) {
            ctx.beginPath();
            ctx.moveTo(x + boxSize / 6, y + boxSize / 6);
            ctx.lineTo(x - boxSize / 6, y - boxSize / 6);
            ctx.stroke();
        }

        // Print hex values inside each box
        ctx.font = '8px Arial';
        ctx.fillText(`A: ${a1}`, x + 2, y + 10);
        ctx.fillText(`B: ${b1}`, x + 2, y + 20);
        ctx.fillText(`O: ${o1}`, x + 2, y + 30);
        ctx.fillText(`d: ${d1}`, x + 2, y + 50);
        ctx.fillText(`c: ${c1}`, x + 2, y + 60);
        ctx.fillText(`s: ${s1}`, x + 2, y + 70);
    });
}


 function updateBox() {
            const input = document.getElementById('updateInput').value;
            const [groupAliasIndex, value] = input.split('=');
            const [order, group, alias, index] = groupAliasIndex.split('.').map(Number);

            console.log(`Updating box at order: ${order}, group: ${group}, alias: ${alias}, index: ${index} with value: ${value}`);

const aliasNames = group === 0 ? ['A','B','O'] : ['dx','cx','sx'];
document.getElementById('selectionDisplay0').textContent =
  `#${order} → ${aliasNames[alias]}[${index}] = ${value}`;

            document.getElementById('selectionDisplay').textContent =`Test Box Entry: Order: ${order}, Group: ${group}, Alias: ${alias}, Index: ${index}, Value: ${value}`;


            if (group === 0) {
                const key = Object.keys(boxes[order].forward[alias])[0];
                boxes[order].forward[alias][key][index] = Number(value);
                console.log(`Updated forward: ${JSON.stringify(boxes[order].forward[alias])}`);
            } else if (group === 1) {
                const key = Object.keys(boxes[order].backward[alias])[0];
                boxes[order].backward[alias][key][index] = Number(value);
                console.log(`Updated backward: ${JSON.stringify(boxes[order].backward[alias])}`);
            }

            document.getElementById('masterBoolDisplay').textContent = formatJSON(boxes[order]);
            drawCanvas(evaluateBoolObject(boxes));        }
  
	window.onload = displayMasterBoolObject;



</script><script>(function(){var s=document.getElementById('zoomSlider'),l=document.getElementById('zoomLabel'),g=document.getElementById('stage');function z(){var v=s?parseInt(s.value,10):100;if(l)l.textContent=v+'%';var k=v/100;if(g){g.style.transform='scale('+k+')';g.style.transformOrigin='top left';}}if(s){s.addEventListener('input',z);z();}})();</script><script>(function(){var inp=document.getElementById('updateInput');if(!inp)return;var c=inp.cloneNode(true);inp.parentNode.replaceChild(c,inp);inp=c;var f=['A','B','O'],b=['dx','cx','sx'];function P(s){s=(s||'').trim();var m=s.match(/^(\d+)\.(\d+)\.(\d+)\.(\d+)\s*=\s*([01])$/);return m?{order:+m[1],group:+m[2],alias:+m[3],index:+m[4],value:+m[5]}:null;}function apply(u){if(!window.boxes||u.order<0||u.order>=boxes.length){var sd=document.getElementById('selectionDisplay');if(sd)sd.textContent='Box '+u.order+' out of range. Currently '+(window.boxes?boxes.length:0)+' boxes';return;}var bx=boxes[u.order];var names=(u.group===0?f:b);var key=names[u.alias]||names[0];var obj=(u.group===0?bx.forward[u.alias]:bx.backward[u.alias]);var inner=Object.keys(obj)[0];obj[inner][u.index]=u.value|0;var sd0=document.getElementById('selectionDisplay0');if(sd0)sd0.textContent='#'+u.order+' → '+key+'['+u.index+'] = '+u.value;var sd=document.getElementById('selectionDisplay');if(sd)sd.textContent='Updated box '+u.order+' '+(u.group===0?'forward':'backward')+' '+key+'['+u.index+'] — ripple recalculation';try{if(typeof evaluateBoolObject==='function'){boxes=evaluateBoolObject(boxes);}}catch(e){console.error('Ripple evaluation failed',e);}if(typeof drawCanvas==='function')drawCanvas(boxes);}function H(){var u=P(inp.value);if(u)apply(u);}inp.addEventListener('input',H);inp.addEventListener('change',H);window.updateBox=function(){var u=P(inp.value);if(u)apply(u);};})();</script></body></html>